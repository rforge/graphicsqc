\documentclass[a4paper,oneside]{report}
%\usepackage[left=3.95cm, right=3.95cm, top=4.9cm, bottom=4.9cm]{geometry}
\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{,}{,}

%\renewcommand\bibname{References}
\newcommand{\R}{\textsf{R}{}}
\newcommand{\graphicsqc}{\textbf{graphicsQC}{}}
\SweaveOpts{keep.source=TRUE}

\title{\textbf{The \graphicsqc{} package}\\
  Quality Control for Graphics in \R{}}
\author{Stephen Gardiner\\\\Supervised by Dr.\ Paul Murrell\\[2cm]
  Department Of Statistics\\
  The University of Auckland\\
  BSc(Hons) Project}
\date{November 2008}

\begin{document}
\maketitle
\begin{abstract}
  The \textbf{graphicsqc} package is a new \R{} package developed for
  extending Quality Control for Graphics in \R{}. It is capable of
  evaluating arbitrary code to produce plots in different file
  formats, while recording information about them. Sets of these plots
  are then able to be compared, with plots of differences produced
  (when available). Lastly, information about these comparisons are
  produced in a HTML report.
\end{abstract}
\tableofcontents

<<echo=FALSE, results=hide>>=
require(graphicsQC)
require(Sxslt)
options(width=60, continue="  ")
@
\chapter{Introduction}
There has been much work into the concept of Quality Control for
software[cite SWEBOK (ch11) -- how?]. There are currently tools in
\R{} which ensure that \R{} code will run without catastrophic
failure, but fewer tools to check that the output from the code is
correct, especially graphics output. Thus, the aim of this research
has been to establish new methods of ensuring Quality Control for
graphics in \R{}. The \graphicsqc{} package has been created for this,
and this report aims to describe how the package works, some features
of it, and the reasoning behind some of the design choices.

In Chapter~\ref{chap:plot}, the process of how plots are created and
the steps taken to record the plots and related information is
described.

Chapter~\ref{chap:compare} describes how the comparison between sets
of plots is performed and some extra features the package provides for this.

Chapter~\ref{chap:report} explains the transformation from log file to report.

\section{Measuring software quality: QC and Regression testing}
Quality Control (QC), or \emph{testing}, is used to ensure quality of
the output of software (as opposed to Quality Assurance (QA) which is
involved with ensuring the correctness of the \emph{process} producing
the output). It is focused on ensuring that the software does not
produce any errors (\emph{crash}), and produces the correct
output. Specifically, QC is useful for the detection of problems
(\emph{bugs}). In terms of graphics, assessing the correctness of
output cannot (initially) be determined without the use of an `expert
observer'. The process of testing whether output is correct or not
will be referred to as \emph{validation}.

Once initial, correct output, has been produced one can test future
outputs against this initial output. This type of testing is known as
\emph{regression testing}. The initial output is referred to as
\emph{control output}. As graphics output is being compared, this
control output has to be initially verified as being correct, so for
the rest of this report it will be referred to as \emph{model output}.
After this model output has been created, changes to the source code
of the software can be made, and the output produced again. This
second set of output is referred to as \emph{test output}. By
comparing this test output against the control output, any changes in
the output can be identified. If there are no differences between the
two, the test output can be validated  as being correct. If a change is
expected, then an expert observer is required to assess whether only
the changes which were expected occurred, and are correct. If this is
the case, the test output now becomes the control output for future
testing.  \citep{ihagen96} and \citep{Rext08} and \citep{murhor03}.

\section{Existing QC functions in \R{}}
% Can't find Hornik article?
There are currently a variety of methods used for quality control in
\R{} \citep{hor02}. When writing packages, there is a \texttt{R CMD
  check} command which will perform a multitude of quality control
tests on a package \citep{Rext08}. Among these tests are checks of the output
produced by the code. Any example code contained in the
documentation of the package is run to ensure that it does not crash
or produce any errors. If a ``tests'' directory exists within the
package, it will evaluate the code in any \texttt{.R} files in the
directory, making sure that they do not produce any errors or crash,
and then compare the output to corresponding \texttt{.Rout.save} files
if they exist. Lastly, it will run code in any package vignettes if
they exist, to test that the code will not crash or produce any
errors. This testing can be manually performed on any package at any
time, however this process is also commonly automated. Examples of
this exist on both the CRAN (The Comprehensive \R{} Archive Network) and
R-Forge websites, which both offer nightly checks and builds of the
packages they host.

% I assume a lot here...
At \R{}'s core, there are also some hard-coded regression tests which
can be run from a `source' distribution of \R{} via the \texttt{make
  check} command. These mainly consist of testing core elements, such
as arithmetic tests, random number generation tests, and so on. They
generally consist of a \texttt{.R} file containing test code to be
evaluated, with a corresponding \texttt{.Rout.save} file which
contains model output. There are however some graphics regression
tests which are also run. These involve running \R{} code which will
open a PostScript device and run code which will produce some plots,
and then use the GNU \texttt{diff} utility to compare the plots to
some supplied model \texttt{.ps.save} plots. This facility is
hard-coded into \texttt{make check} and is not performed by \texttt{R
  CMD check}. Thus the current level of quality control for graphics
in \R{} is very limited and is available only for a few pre-defined
plots, and only when using a source distribution of \R{}.
% Cran also does nightly `make checks' of R?

% Hmm: Diff is assumed to be available on supported platforms,
% when R gets built does it need diff to compare the .ps.save files?
% Does it actually compare them? I tried a test for a package and
% R CMD check doesn't do it.

% Kurt Hornik will eventually summarise QC in R (at 2003)?
% https://stat.ethz.ch/pipermail/r-sig-qa/2003-May/000005.html?


\section{An early attempt at QC for graphics in \R{}}
An early attempt at graphics testing for \R{} is a package similarly
named \graphicsqc{} written by Paul Murrell \citeyearpar{murhor03}. It
was essentially a proof-of-concept package, and is very limited in
usability and functionality. It is limited to only running regression
tests on the example code in given functions in \R{}. It does not
record or return any information pertaining to the plots (such as
which directory the plots are being stored), and had very little error
checking. For most of the supported file formats, if any differences
were detected, a vector naming the test files with differences were
returned, with no other information. For the files in the \texttt{pbm}
format, an \texttt{xor} operation is perfomed on the plots and a
difference plot produced which gives a visual representation of the
differences between the plots, however this is not supported on any
other file format. % should I be more harsh?

Due to these limitations, the package required a complete re-write to
become more useful. Some features necessitating this are the ability
to record information relating to the plots, such as which plots were
created in which directory, which call created the plots, and so
on. Another necessary feature is the ability to plot any arbitrary
expressions, which can then be extended to plotting files and also
examples from functions. As this occurs, it would also be useful to
appropriately record any warnings which occur, and then possibly
difference these as they may be useful for discovering why plots
differ. The current \graphicsqc{} package is a complete re-write of
this previous implementation.

\section{Outline of \textbf{graphicsQC}}
The nature of what's required of the package reflects well with its
design. The first component of regression testing involves creating
model output. This is accomplished by one of the three functions
\texttt{plotExpr()}, \texttt{plotFile()} and
\texttt{plotFunction()}. These evaluate and plot arbitrary
expressions, code within files, and example code from functions
respectively. They also record information about the plots they
produce, including any warnings or errors which may have
occurred. These functions are used for creation of both the model and
test output and are further described in Chapter~\ref{chap:plot}.

Once the model and test output have been created, they need to be
compared for differences. For this, there is the \texttt{compare()}
function. The \texttt{compare()} function will compare two sets of
plots, for example two sets produced by \texttt{plotFunction()}. It
can compare using the \R{} objects of the logs, or paths to the
resulting logs, or a mixture of these. It uses the GNU \texttt{diff}
utility to do the comparisons, which can be assumed on all of \R{}'s
supported platforms \citep{Rext08}[change cite to R extensions?]. It
compares the plots and any warnings or errors for differences and then
records the result of the comparison. The \texttt{compare()} function
is further described in Chapter~\ref{chap:compare}.

Lastly, it may be desirable to report about the plots and the
comparisons. The function \texttt{writeReport()} is used for
this. \texttt{writeReport()} generates a HTML page of the results of
any plotting or comparison result. It is further discussed in
Chapter~\ref{chap:report}.

\chapter{Plotting Arbitrary Expressions}
\label{chap:plot}
\section{Plotting expressions}
\label{sec:plotExpr}
In order to test the correctness of output, it follows that output
must have initially been produced. For this task, the function
\texttt{plotExpr()} was created. The main concept behind
\texttt{plotExpr()} is to evaluate plotting code under chosen graphics
devices, and record which plots were produced and related information
(such as operating system, date, directory, \R{} version and so on). It
does this by initially error checking it's arguments, and then making
a call to a function within the namespace, \texttt{evalPlotCode()}.

\texttt{evalPlotCode()} is reponsible for evaluating code after
opening an appropriate graphics device. It uses the \texttt{tryCatch}
mechanism in \R{} to ensure that the function can continue evaluation
if there is an error in the code being evaluated. With the use of
calling handlers, it is also able to `catch' warnings and store
them. If an error is encountered, this is also recorded and evaluation
of the current set of expressions is stopped. This is intentional
because an error in the code is likely to be something serious which
will affect future expressions in the current set and possibly
plots. Warnings however are not considered to be stop-worthy, so
evaluation will continue after recording the warning. How this
information is recorded is discussed in section~\ref{sec:logs}.

The call to \texttt{evalPlotCode()} is made within \texttt{plotExpr()}
using the \texttt{lapply()} function. There are two advantages for
this. First, the computation is vectorised, which \R{} has been
optimised for. Secondly, it ensures that \texttt{evalPlotCode()} gets
called once for each file format for the expression, so any warnings
or errors are captured separately by filetype. This is because some
warnings may only occur on a certain graphics device and this ensures
that the devices are treated separately to each other.Using many file
formats is a distinct advantage in that all graphics formats can be
tested against themselves to help identify whether changes in graphics
output are due to the underlying code used to produce the respective
graphics, or whether there is a problem or change with a specific
graphics driver.

% hooks?
A special case to consider when evaluating plotting code is any code
which will not actually produce any plots. Due the large variety of
functions in \R{}, and the ability to create your own on the fly, it
is unfeasible to determine whether code will produce plots without
first evaluating it. So initially \texttt{evalPlotCode()} will open
the appropriate graphics device, evaluate the code, and then close the
device. If no plot is produced, this will leave a `blank' image in the
chosen file format. These `blank' images are not always blank in the
sense that some information is written to file. This information
differs by file format and so the resulting sizes of files will be
different. These plots are not of interest when creating plots as they
do not represent a plot produced by \R{}. To deal with this,
\texttt{plotExpr()} calls \texttt{generateBlankImages()} which
generates `blank' images in a temporary directory for the (supported)
file formats which produce `blank' files of non-zero size. The plots
which are produced are then compared to these model `blank' images,
and removed if they are the same size, that is, completely
blank. However, warnings and errors are still recorded in these
situations.

A similar problem faced is that \R{} cannot reliably determine how
many plots will be produced from a given set of expressions, and so it
is difficult to establish which plots were produced. The plots are
named with a prefix according to what is specified as the
\texttt{prefix} argument, along with a numbered suffix to identify
each plot. That is, plots are created and then detected via the chosen
prefix. As a consequence, care must be taken when choosing a
\texttt{prefix} for the plots which is unique within a directory so
that the plots which are created can be distinguished from other files
in the directory. The chosen directory to produce plots in is checked
prior to evaluating the code for any currently existing files which
might be created by the function. A \texttt{clear} argument to the
function is available which first clears the directory of any files
with a name the same as any which might be created.

Thus, the arguments to \texttt{plotExpr} are of the order,
\texttt{expr}, which is a character vector (or an expression object)
of the expressions to evaluate which may produce graphical
output. Next is \texttt{filetype}, which is used to specify which file
formats the expressions should be evaluated in. \texttt{path} is the
path to place the plots and log in. \texttt{prefix} is the prefix to
use for the files, and \texttt{clear} specifies whether to first
remove files which already exist with a name like any which might be
created. The resulting object is given the class \texttt{qcPlotExprResult}.

An example is given below. % might manually do this one.. doesn't print well..
<<first>>=
first <- plotExpr(c("y <- 10", "x <- 1", "plot(x:y)", "z <- 5"),
           c("pdf", "png"), "exampleDir", "firstExample")
first
@

\section{Plotting files and functions}
\label{sec:plotF}
A function for plotting arbitrary expressions has already been
defined. It can be seen that plotting files or functions is simply an
extension of this, where multiple files may each correspond to a
different `expression', and likewise for functions where each function
corresponds to a different expression. This is particularly true for
functions, where the plots for each function a generated by a single
call to \texttt{example()} of each function.

The two functions which provide these facilities are
\texttt{plotFile()} and \texttt{plotFunction()}. They both essentially
consist of checking their arguments, then generating multiple calls to
\texttt{plotExpr()} for each file or function they are called with
respectively. Thus the resulting objects contain lists of
\texttt{qcPlotExprResult} objects.  These \texttt{plotFile()} and
\texttt{plotFunction()} calls are actually important in themselves as
they need to refer to a grouping of \texttt{qcPlotExprResult}
objects. Thus they also contain their own set of information similar
to those stored in \texttt{qcPlotExprResult} objects. These results
are classed as \texttt{qcPlotFileResult} and \texttt{qcPlotFunResult}
respectively.

There is now some intrinsic classing hierachy as
\texttt{qcPlotFileResult} objects and \texttt{qcPlotFunResult} objects
both contain \texttt{qcPlotExprResult} objects, plus some extra
information, so these objects can be considered as super-classes to
\texttt{qcPlotExprResult}. Conceptually, this is easily extended to
the ability to plot entire packages, as they would consist of multiple
sets of \texttt{qcPlotFileResult} and \texttt{qcPlotFunResult}
objects, and thus \texttt{qcPlotPackageResult} would be a super-class
of these. The ability to plot entire packages, for example
\texttt{plotPackage()}, is not yet entirely implemented, but a close
approximation can be made as shown in Chapter~\ref{chap:grid}. This
classing structure is shown in Figure~\ref{fig:plotClass}

\begin{figure}
  \centering
    \includegraphics[height=7cm,keepaspectratio=true]{plotClass}
  \caption{Classing structure for `plot' objects}
  \label{fig:plotClass}
\end{figure}

How these are recorded as logs is described in the next section.

An example of plotting the \texttt{barplot()} function is given below.
<<barplot>>=
bplot <- plotFunction(barplot, c("pdf", "ps", "png"), "barplot")
@

\section{Logs of plots created}
\label{sec:logs}
% Mention XML doesn't fully work on MacOS? see CRAN?
When creating plots, it is very useful to store information about
them. Primarily, information such as which plots were produced in
which file formats, and which warnings or errors were generated within
these file formats is of interest. However information such as
operating system, date, \R{} version, and which call was used to create
the plots is also useful. All of this information cannot be stored as
a part of each plot, so a separate log file must be created.

As it is only text which needs to be stored, it makes sense to store
this information in a text-based format, especially as it will be
easier to read log files in the future. The logs were chosen to be
stored using XML which is described in the next section. In order to
create XML documents in \R{}, the \textbf{XML} package has been used
\citep{lan01}.

\subsection{The XML Language}
The e\textbf{X}tensible \textbf{M}arkup \textbf{L}anguage (XML) is a
markup language for documents containing structured information. It is
extensible due to the ability for users to define their own
elements. It is an `open standard' which agrees with the open nature
of \R{}. Some of the main advantages for using XML are it's
extensibility for user-defined elements, it is self-documenting,
platform independent, relatively human-legible, and internationally
recognised. This allows for great flexibility to store structured
logs, as well as ease of reading in stored logs. A disadvantage of XML
is that it is very verbose, and so can take up more disk space than if
the log was stored using a binary format. This effect is considered to
be negligible however, since the disk space required for plots will
far outweigh the disk space required to store lists of the names of
them in XML.

\subsection{\texttt{plotExpr()} XML logs}
The logs produced by \texttt{plotExpr()} consist of two parts. The
first part consists of information related to the plots, such as
operating system, \R{} version, date, and call. The second part
consists of the results of evaluating the code, such as the plots
produced by the code, listed by file format, including warnings or
errors.

The log created from section~\ref{sec:plotExpr} (firstExample-log.xml)
is given below.

<<firstXML, echo=FALSE>>=
plotExprLog <- system("cat exampleDir/firstExample-log.xml", intern = TRUE)
cat(plotExprLog, sep = "\n")
@

The XML markup being used is fairly self-explanatory. Only 2 plots
were created; one in PDF and one in PostScript, with neither having
any warnings or errors. It is worth pointing out that the log includes
it's own \texttt{logFilename}. This is so the object in \R{} knows
where the file exists on disk.

Due to this completely open and platform independent way of storing
this information, the process can be taken out of \R{} at any point.
For example if the user only wished to create the plots and then do
something else with them, the information is stored in an easily
accessible format for them.

%- show how it's done (split info and main?) - and plotFile and plotFun
%since they've now been explained?. process can now be taken out of
%R. freedom of choice.
\subsection{\texttt{plotFile()} and \texttt{plotFunction()} XML logs}
As \texttt{qcPlotFileResult} and \texttt{qcPlotFunResult} objects are
simply lists of \texttt{qcPlotExprResult} objects with some extra
information, the type of log files they create represent this
structure. Both \texttt{qcPlotFileResult} and \texttt{qcPlotFunResult}
files contain an information section, followed by the paths to all of
the \texttt{qcPlotExprResult} files that they made. This is a more
efficient usage of disk space as all of the information in the
\texttt{qcPlotExprResult} files does not need to be repeated. It also
has the advantage that no changes are needed to \texttt{plotExpr()} as
it can continue producing the logs it already does, with
\texttt{plotFile()} or \texttt{plotFunction()} only producing an extra
log file to refer to all the produced logs. It is worth noting that
the \R{} representations of \texttt{qcPlotFileResult} and
\texttt{qcPlotFunResult} objects contain complete information, that is,
all of the information contained in the sub-\texttt{qcPlotExprResult}
objects as well.

The log file produced from the \texttt{barplot()} example in
section~\ref{sec:plotF} is given below.

% goes off the page
<<barplotXML, echo=FALSE>>=
plotFunLog <- system("cat barplot/barplot-funLog.xml", intern = TRUE)
cat(plotFunLog, sep = "\n")
@

The naming of these \texttt{qcPlotFileResult} and
\texttt{qcPlotFunResult} files requires extra care when more than one
file or function is specified. In the example given above, the
filename was \texttt{barplot-funLog.xml}, as only one function was
specified. If multiple files or functions are specified, the prefix
used is chosen to be the first element in the \texttt{prefix}
vector. Any other choice will inevitably result in a filename too long
for the system.

\chapter{Comparing plots}
\label{chap:compare}
- GNU diff/ImageMagick are used. Diff plots only made when a diff is
detected, however not made when they are going to be erased afterwards
(although erase doesn't fully work yet)?
\section{Comparing sets of expressions}
\subsection{Text Based vs. Bitmap Formats}

- explanation. 3 file formats currently supported (mention this
earlier?). can use xor to create plots for bitmaps? .diff files only
make sense for text based. advantages and disadvantages for both?

\subsection{Pairing plots}
- how logs are paired? unpaired.

% The next step in the process is to compare a set of plots to another;
% typically between two different versions of \R{} to establish if the
% graphics outputs have changed, but could also be used to detect
% whether changes made to the graphics system or to specific functions
% are different to previously known correct control group outputs.

% GNU diff is used.

% To detect the differences, the utility \texttt{diff} is used, which is
% assumed on all supported platforms according to the \R{} Coding
% Standards (Writing \R{} Extensions). An extension to this has been to use
% the ImageMagick software to also create plots of the differences when
% available. A drawback to this is that the ImageMagick software must
% first be installed, but it is open-source, free, and is readily
% available for many operating systems or even from source. While it is
% a distinct advantage to use the ImageMagick software, it is also not a
% requirement as the differences will still be detected by
% \texttt{diff}, but plots of the differences will not be created.

% \noindent For example, to create two plots which will be different
% from each other:
% \begin{verbatim}
% > control <- plotExpr("hist(rep(1:10,1:10), breaks=6)", "png", "histControl")
% > test <- plotExpr("hist(rep(10:1,1:10), breaks=6)", "png", "histTest")
% > compare(test, control, erase="none")
% \end{verbatim}

% \noindent Which informs us that the plots are indeed different:
% \begin{verbatim}
% /home/stephen/histControl-1.png
%                     "different"
% \end{verbatim}

% \noindent And an appropriate plot of the differences is also produced,
% with the differences highlighted in red:

%\begin{center}
%\includegraphics[width=9cm]{diffplot.png}
%\end{center}

% While this was a trivial example of a single expression, the ability
% to compare example code from entire functions has also been
% implemented, with lists of the identical and different files and
% corresponding plots of the differences produced and also the ability
% to handle extreme cases such as when new plots have been added in the
% test group which don't have a corresponding pair in the control group.

\section{Comparing sets of files and functions}
\section{Auto-detection of logs} % plot AND compare logs
- One of the features.. easier for users (especially when comparing in
separate versions of \R{} and having to find the exact file name).
\section{Extensibility for new file formats}

- use of mapply in compareType nested in lapply in compareExpr (give
some gory details!?) - allows for compareNEWTYPE where the function
will get automatically called with the new filetype (plus would need
to include the filetype in the `valid filetypes' list).

\chapter{Generating Reports}
\label{chap:report}

\section{The XSL Language}
- stylesheet language for xml. Define templates of how to display elements.

\section{Transforming XML logs into HTML reports}
- logs are in xml, xslt seems the perfect choice (remember, this
option is left open for other users). some default style sheets are
provided, but are easily overwritten!

.. uses \cite{sxslt}.
\chapter{A real example: \textbf{grid}}
\label{chap:grid}

\section{Plotting functions in the \textbf{grid} package}
- ls("package:grid") (of course, don't show everything)

\section{Comparing the \textbf{grid} functions}
- maybe show the print.qcCompareExpr result for one of the functions
(even though it doesn't fully work..)?

\section{Reporting on the differences in \textbf{grid}}
- print screen from firefox? any better way? link to example on
http://graphicsqc.r-forge.r-project.org?

\chapter{Summary and discussion}
can't supply all model output...?

- what's been done?
  + new package
  + plots stuff, compares stuff, pretty neat report
- what can be improved?
  + plot/compare/writeReport package
  + print<lots>
  + compare(erase)
  + DTDs for logs
  + completely unpaired fun/file
  + mac (XML doesn't work)? windows (Sxslt not ported to windows!)
                            few developers.

% A powerful method of doing regression testing for graphics has been
% implemented in \R{}. The current method consists of generating sets of
% plots for the control and test groups, and then comparing them. It is
% a major improvement on earlier work as it is now platform independent,
% able to run any arbitrary code, and able to produce plots of
% differences. It significantly improves the reliability and quality of
% graphics testing in \R{}.

% The current implementation still has much room for improvement. Using
% the current implementation as a base, the package could be extended to
% include a function to plot and compare entire packages, which will
% simply be an extension of the current functions which plot and compare
% other functions. A function to write a report (such as an HTML report)
% based on the comparisons would also be a useful addition to the
% package. Lastly a wrapper class to combine plotting, comparing, and
% reporting into one step would be a clear finalisation of the package.

%\appendix
\clearpage
\addcontentsline{toc}{chapter}{Appendix A: Documentation}
%\renewcommand\thesection{Appendix \Alph{section}}
\chapter*{Documentation}
The latest version of the package can be installed from within \R{} via the
following command:
<<eval=FALSE>>=
install.packages("graphicsQC", repos="http://R-Forge.R-project.org")
@
Noting that the \textsf{XML} package is a dependency, so must also be
installed, and \textsf{Sxslt} must also be installed if \textsf{HTML}
reports are desired.

The latest version of the package can also be downloaded in unix directly from
the Subversion repository, when issuing a command such as:
\begin{verbatim}
svn checkout svn://svn.r-forge.r-project.org/svnroot/graphicsqc
\end{verbatim}
at the unix prompt.

To download the current revision at the time of printing (revision
??), the following command can be used:
\begin{verbatim}
svn checkout --revision ?? svn://svn.r-forge.r-project.org/svnroot/graphicsqc
\end{verbatim}

The rest of the in-\R{} documentation follows on the next page.
\nocite{R}
\clearpage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plainnat}
\bibliography{references}
% include references to XML and Sxslt from R News?

\end{document}
